# app_cadin.py — Consulta CADIN (PF e PJ) • Gateway / SERPRO / PMSP
# Autor: você :)  •  Refatorado para: título único, UX melhor, validações e lote
# Observação: este app opera em DEMO se nenhum gateway/secrets estiver configurado.

from __future__ import annotations

import os
import re
from typing import Dict, Any, List, Optional, Tuple

import requests
import pandas as pd
import streamlit as st

# ========================= Página / Cabeçalho =========================
st.set_page_config(page_title="CADIN • Consulta PF e PJ", layout="wide")

APP_TITLE = "📌 Consulta CADIN (PF e PJ)"
APP_CAPTION = (
    "Fluxo: **Gateway** (recomendado) → **SERPRO** (opcional) → **DEMO**. "
    "Para o **CADIN Municipal (PMSP)**, habilite o gateway próprio (PF exige data de nascimento). "
    "Campos aceitam CPF/CNPJ **com ou sem máscara**."
)

st.title(APP_TITLE)
st.caption(APP_CAPTION)

# ========================= Config por Secrets/Env =========================
# Geral (federal/outros)
GATEWAY_URL       = os.getenv("GATEWAY_URL", "").strip()           # ex: https://seu-backend.exemplo.app
INTERNAL_API_KEY  = os.getenv("INTERNAL_API_KEY", "").strip()      # header X-API-Key

# SERPRO direto (opcional)
SERPRO_BASE       = os.getenv("SERPRO_CADIN_BASE", "").strip()     # ex: https://apicadin.serpro.gov.br
SERPRO_TOKEN      = os.getenv("SERPRO_TOKEN", "").strip()          # Bearer

# PMSP (via seu gateway que resolve captcha/autorização)
PMSP_GATEWAY_URL  = os.getenv("PMSP_GATEWAY_URL", "").strip()      # ex: https://seu-gateway-pmsp.exemplo.app
PMSP_API_KEY      = os.getenv("PMSP_API_KEY", "").strip()

# ========================= Utilitários =========================
DIGITS_RE = re.compile(r"\D+")

def only_digits(s: str) -> str:
    return DIGITS_RE.sub("", s or "")

def is_cpf(d: str) -> bool:
    d = only_digits(d)
    return len(d) == 11

def is_cnpj(d: str) -> bool:
    d = only_digits(d)
    return len(d) == 14

def label_doc(d: str) -> str:
    d = only_digits(d)
    return "CPF" if len(d) == 11 else "CNPJ" if len(d) == 14 else "Documento"

def fmt_doc(d: str) -> str:
    d = only_digits(d)
    if len(d) == 11:
        return f"{d[:3]}.{d[3:6]}.{d[6:9]}-{d[9:]}"
    if len(d) == 14:
        return f"{d[:2]}.{d[2:5]}.{d[5:8]}/{d[8:12]}-{d[12:]}"
    return d

def http_get_json(url: str, *, headers: Dict[str, str] | None = None, params: Dict[str, str] | None = None, timeout: int = 40) -> Dict[str, Any]:
    r = requests.get(url, headers=headers or {}, params=params or {}, timeout=timeout)
    r.raise_for_status()
    return r.json()

# ========================= Clientes/Providers =========================
@st.cache_data(ttl=600, show_spinner=False)
def fetch_cadin_via_gateway(document: str) -> Dict[str, Any]:
    """
    Gateway padrão (federal/geral).
    Esperado JSON compatível: {"documento":"...", "nome"/"razao_social":"...", "situacao": "...", "pendencias":[...] }
    """
    if not (GATEWAY_URL and INTERNAL_API_KEY):
        raise RuntimeError("Gateway padrão não configurado")
    url = f"{GATEWAY_URL.rstrip('/')}/cadin/{only_digits(document)}"
    return http_get_json(url, headers={"X-API-Key": INTERNAL_API_KEY}, timeout=40)

@st.cache_data(ttl=600, show_spinner=False)
def fetch_cadin_via_serpro_direct(document: str) -> Dict[str, Any]:
    """Exemplo de chamada direta ao SERPRO (ajuste payload conforme contrato)."""
    if not (SERPRO_BASE and SERPRO_TOKEN):
        raise RuntimeError("SERPRO não configurado")
    url = f"{SERPRO_BASE.rstrip('/')}/cadin/v1/consulta/{only_digits(document)}"
    return http_get_json(url, headers={"Authorization": f"Bearer {SERPRO_TOKEN}"}, timeout=45)

@st.cache_data(ttl=600, show_spinner=False)
def fetch_cadin_pmsp_pf(cpf: str, dtnasc_ddmmaaaa: str) -> Dict[str, Any]:
    """
    PMSP (PF) via gateway. JSON compatível com normalização:
    {"cpf":"...", "nome":"...", "situacao":"...", "pendencias":[...] }
    """
    if not (PMSP_GATEWAY_URL and PMSP_API_KEY):
        raise RuntimeError("Gateway PMSP não configurado")
    url = f"{PMSP_GATEWAY_URL.rstrip('/')}/cadin/pmspspf/{only_digits(cpf)}"
    return http_get_json(url, headers={"X-API-Key": PMSP_API_KEY}, params={"dtnasc": dtnasc_ddmmaaaa}, timeout=45)

@st.cache_data(ttl=600, show_spinner=False)
def fetch_cadin_pmsp_pj(cnpj: str) -> Dict[str, Any]:
    """PMSP (PJ) via gateway."""
    if not (PMSP_GATEWAY_URL and PMSP_API_KEY):
        raise RuntimeError("Gateway PMSP não configurado")
    url = f"{PMSP_GATEWAY_URL.rstrip('/')}/cadin/pmspspj/{only_digits(cnpj)}"
    return http_get_json(url, headers={"X-API-Key": PMSP_API_KEY}, timeout=45)

# ========================= Normalização de payload =========================
def normalize_payload(data: Dict[str, Any], doc: str) -> Dict[str, Any]:
    """
    Resultado padrão:
    {
      "documento": "11 dígitos CPF ou 14 CNPJ",
      "nome": "nome/razão",
      "situacao": "REGULAR|IRREGULAR|...",
      "pendencias": [ ... lista de dicts ... ],
      "_raw": data original
    }
    """
    out: Dict[str, Any] = {}
    out["documento"] = only_digits(data.get("documento") or data.get("cpf") or data.get("cnpj") or doc)
    out["nome"] = data.get("nome") or data.get("razao_social") or data.get("razaoSocial") or "—"
    out["situacao"] = (data.get("situacao") or data.get("status") or "—").upper()
    pend = data.get("pendencias") or data.get("itens") or data.get("debts") or []
    if isinstance(pend, dict):  # garante lista
        pend = [pend]
    out["pendencias"] = pend
    out["_raw"] = data
    return out

def demo_payload(document: str) -> Dict[str, Any]:
    """Modo demonstração (sem consulta real)."""
    d = only_digits(document)
    is_pf = is_cpf(d)
    irregular = (int(d[-1]) % 2 == 1) if d else False
    nome = "Pessoa Física (demo)" if is_pf else "Empresa Ltda (demo)" if is_cnpj(d) else "Documento (demo)"
    data = {
        "documento": d,
        "nome": nome,
        "situacao": "IRREGULAR" if irregular else "REGULAR",
        "pendencias": [] if not irregular else [
            {"orgao": "PMSP" if is_pf else "União", "origem": "Tributo", "numero": "000123/2024", "data": "2024-08-12", "valor": 199.90}
        ],
    }
    return normalize_payload(data, d)

# ========================= Orquestração =========================
def resolve_general(document: str) -> Tuple[Dict[str, Any], str]:
    """
    Gateway → SERPRO → DEMO
    Retorna (payload_normalizado, fonte).
    """
    # 1) Gateway
    if GATEWAY_URL and INTERNAL_API_KEY:
        try:
            data = fetch_cadin_via_gateway(document)
            return normalize_payload(data, document), "gateway"
        except Exception as e:
            st.warning(f"Gateway falhou: {e}")

    # 2) SERPRO
    if SERPRO_BASE and SERPRO_TOKEN:
        try:
            data = fetch_cadin_via_serpro_direct(document)
            return normalize_payload(data, document), "serpro"
        except Exception as e:
            st.warning(f"SERPRO falhou: {e}")

    # 3) DEMO
    return demo_payload(document), "demo"

def resolve_pmsp(document: str, dtnasc: Optional[str]) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
    """
    PMSP PF/PJ via gateway.
    - PF exige dtnasc dd/mm/aaaa
    - PJ só CNPJ
    """
    if not (PMSP_GATEWAY_URL and PMSP_API_KEY):
        return None, None

    if is_cpf(document):
        if not dtnasc or not re.match(r"^\d{2}/\d{2}/\d{4}$", dtnasc.strip()):
            st.error("Para **PMSP – PF**, informe **data de nascimento** (dd/mm/aaaa).")
            return None, None
        try:
            data = fetch_cadin_pmsp_pf(document, dtnasc.strip())
            return normalize_payload(data, document), "pmsp_pf"
        except Exception as e:
            st.warning(f"PMSP PF falhou: {e}")
            return None, None

    if is_cnpj(document):
        try:
            data = fetch_cadin_pmsp_pj(document)
            return normalize_payload(data, document), "pmsp_pj"
        except Exception as e:
            st.warning(f"PMSP PJ falhou: {e}")
            return None, None

    st.error("Documento inválido para PMSP.")
    return None, None

# ========================= Sidebar / Modo =========================
with st.sidebar:
    st.subheader("⚙️ Configurações")

    if GATEWAY_URL and INTERNAL_API_KEY:
        st.success("Gateway padrão configurado")
        st.caption(f"**Gateway:** {GATEWAY_URL}")
    else:
        st.info("Sem gateway padrão. Configure **GATEWAY_URL** e **INTERNAL_API_KEY**.")

    if SERPRO_BASE and SERPRO_TOKEN:
        st.success("SERPRO direto configurado (opcional)")
    else:
        st.info("Sem SERPRO direto (opcional)")

    if PMSP_GATEWAY_URL and PMSP_API_KEY:
        st.success("Gateway **PMSP** configurado")
        pmsp_on = st.checkbox("Usar CADIN Municipal (PMSP) quando possível", value=True)
    else:
        st.info("Sem gateway PMSP. Configure **PMSP_GATEWAY_URL** e **PMSP_API_KEY**.")
        pmsp_on = False

    st.markdown("---")
    mode = st.radio("Modos de consulta", ["Consulta única", "Lote (CSV)"], index=0)

# ========================= UI: Cartão de Resultado =========================
def show_result_card(payload: Dict[str, Any], fonte: str) -> None:
    doc = payload.get("documento", "")
    st.subheader(f"Resultado — {label_doc(doc)} {fmt_doc(doc)}")
    st.write("**Fonte:**", fonte.upper())
    st.write("**Nome/Razão social:**", payload.get("nome", "—"))

    situ = (payload.get("situacao") or "—").upper()
    st.write("**Situação:**", "🟥 IRREGULAR" if situ == "IRREGULAR" else "🟩 REGULAR")

    st.markdown("---")
    st.subheader("🔎 Pendências")
    pend = payload.get("pendencias") or []
    if not pend:
        st.success("Sem pendências retornadas.")
    else:
        df = pd.DataFrame(pend)
        if "valor" in df.columns:
            with pd.option_context("mode.use_inf_as_na", True):
                df["valor"] = pd.to_numeric(df["valor"], errors="coerce")
        st.dataframe(df, use_container_width=True)

    with st.expander("JSON bruto / depuração"):
        st.json(payload.get("_raw", payload))

# ========================= UI: Consulta Única =========================
def render_single(pmsp_on: bool) -> None:
    with st.form("form_single"):
        doc = st.text_input("CPF ou CNPJ", placeholder="000.000.000-00 ou 00.000.000/0001-00")
        dtnasc = st.text_input("Data de nascimento (PMSP – PF)", placeholder="dd/mm/aaaa") if pmsp_on else ""
        submitted = st.form_submit_button("Consultar")

    if not submitted:
        return

    clean = only_digits(doc)
    if len(clean) not in (11, 14):
        st.error("Informe um CPF (11 dígitos) ou CNPJ (14 dígitos).")
        return

    with st.spinner("Consultando..."):
        payload: Optional[Dict[str, Any]] = None
        fonte: Optional[str] = None

        # 1) PMSP preferencialmente (se habilitado)
        if pmsp_on:
            payload, fonte = resolve_pmsp(clean, dtnasc)

        # 2) fallback p/ fluxo geral
        if payload is None:
            payload, fonte = resolve_general(clean)

    show_result_card(payload, fonte or "desconhecida")

# ========================= UI: Lote (CSV) =========================
def render_batch(pmsp_on: bool) -> None:
    st.write(
        "Envie um **CSV** com coluna `documento` (CPF/CNPJ). "
        "Se **PMSP** estiver ativo e o documento for **CPF**, inclua coluna `dtnasc` (dd/mm/aaaa)."
    )

    # botão de template
    tpl = pd.DataFrame({"documento": ["00000000000", "00000000000000"], "dtnasc": ["01/01/1990", ""]})
    st.download_button(
        "Baixar template CSV",
        tpl.to_csv(index=False).encode("utf-8-sig"),
        file_name="template_cadin.csv",
        mime="text/csv",
        use_container_width=True
    )

    file = st.file_uploader("CSV", type=["csv"])
    if not file:
        return

    try:
        df = pd.read_csv(file, dtype=str).fillna("")
    except Exception as e:
        st.error(f"Erro ao ler CSV: {e}")
        return

    if "documento" not in df.columns:
        st.error("CSV deve conter a coluna `documento`.")
        return

    docs: List[str] = [only_digits(x) for x in df["documento"].astype(str).tolist()]
    docs = [d for d in docs if len(d) in (11, 14)]
    if not docs:
        st.error("Nenhum CPF/CNPJ válido encontrado.")
        return

    out_rows: List[Dict[str, Any]] = []
    prog = st.progress(0.0)
    total = len(docs)

    for i, d in enumerate(docs, start=1):
        payload: Optional[Dict[str, Any]] = None
        fonte: Optional[str] = None

        if pmsp_on:
            dtn = ""
            if is_cpf(d) and "dtnasc" in df.columns:
                # tenta pegar linha correspondente (mesmo índice) — se faltar, segue vazio
                try:
                    dtn = str(df.loc[df.index[i - 1], "dtnasc"]).strip()
                except Exception:
                    dtn = ""
            p, f = resolve_pmsp(d, dtn)
            if p is not None:
                payload, fonte = p, f

        if payload is None:
            payload, fonte = resolve_general(d)

        pend = payload.get("pendencias") or []
        out_rows.append(
            {
                "documento": fmt_doc(d),
                "tipo": label_doc(d),
                "nome": payload.get("nome", ""),
                "situacao": payload.get("situacao", ""),
                "qtd_pendencias": len(pend),
                "fonte": (fonte or "—"),
            }
        )
        prog.progress(i / total)

    out = pd.DataFrame(out_rows)
    st.subheader("📊 Resumo do lote")
    st.dataframe(out, use_container_width=True)
    st.download_button(
        "Baixar resultado (CSV)",
        out.to_csv(index=False).encode("utf-8-sig"),
        file_name="resultado_cadin.csv",
        mime="text/csv",
        use_container_width=True
    )

# ========================= Main =========================
with st.sidebar:
    st.markdown("---")

if mode == "Consulta única":
    render_single(pmsp_on)
else:
    render_batch(pmsp_on)

st.markdown("---")
st.caption(
    "Observação: Sistemas CADIN (Federal, Estadual e Municipal/PMSP) são bases restritas; "
    "este app deve ser usado com **credenciais oficiais** e finalidade legítima. "
    "Sem credenciais, opera em **modo demonstração**."
)
