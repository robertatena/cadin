# streamlit_app.py ‚Äî CADIN PF e PJ (simples, 1 t√≠tulo, sem checkbox LGPD)
import os
import re
from typing import Any, Dict, List, Optional, Tuple

import requests
import pandas as pd
import streamlit as st

# =========================
# Config da p√°gina
# =========================
st.set_page_config(page_title="CADIN ‚Ä¢ Consulta PF e PJ", layout="wide")

TITLE = "üìå Consulta CADIN (PF e PJ)"
SUBTITLE = (
    "Fluxo padr√£o: Gateway (recomendado) ‚Üí SERPRO (opcional) ‚Üí modo demonstra√ß√£o. "
    "Para CADIN Municipal da **Prefeitura de S√£o Paulo (PMSP)**, use o gateway PMSP (PF e PJ)."
)

st.title(TITLE)
st.caption(SUBTITLE)

# =========================
# Vari√°veis de ambiente (secrets)
# =========================
GATEWAY_URL      = os.getenv("GATEWAY_URL")       # ex.: https://seu-backend.exemplo.app
INTERNAL_API_KEY = os.getenv("INTERNAL_API_KEY")  # header X-API-Key do seu gateway

SERPRO_BASE  = os.getenv("SERPRO_CADIN_BASE")     # ex.: https://apicadin.serpro.gov.br
SERPRO_TOKEN = os.getenv("SERPRO_TOKEN")          # token/bearer do SERPRO

PMSP_GATEWAY_URL = os.getenv("PMSP_GATEWAY_URL")  # ex.: https://seu-gateway-pmsp.exemplo.app
PMSP_API_KEY     = os.getenv("PMSP_API_KEY")

# =========================
# Utils
# =========================
def only_digits(s: str) -> str:
    return re.sub(r"\D+", "", s or "")

def is_cpf(doc: str) -> bool:
    return len(only_digits(doc)) == 11

def is_cnpj(doc: str) -> bool:
    return len(only_digits(doc)) == 14

def label_doc(doc: str) -> str:
    d = only_digits(doc)
    if len(d) == 11: return "CPF"
    if len(d) == 14: return "CNPJ"
    return "Documento"

def fmt_doc(doc: str) -> str:
    d = only_digits(doc)
    if len(d) == 11:
        return f"{d[:3]}.{d[3:6]}.{d[6:9]}-{d[9:]}"
    if len(d) == 14:
        return f"{d[:2]}.{d[2:5]}.{d[5:8]}/{d[8:12]}-{d[12:]}"
    return d

# =========================
# Clientes HTTP
# =========================
@st.cache_data(ttl=600, show_spinner=False)
def via_gateway(document: str) -> Dict[str, Any]:
    if not (GATEWAY_URL and INTERNAL_API_KEY):
        raise RuntimeError("Gateway padr√£o n√£o configurado.")
    url = f"{GATEWAY_URL.rstrip('/')}/cadin/{only_digits(document)}"
    r = requests.get(url, headers={"X-API-Key": INTERNAL_API_KEY}, timeout=45)
    r.raise_for_status()
    return r.json()

@st.cache_data(ttl=600, show_spinner=False)
def via_serpro(document: str) -> Dict[str, Any]:
    if not (SERPRO_BASE and SERPRO_TOKEN):
        raise RuntimeError("SERPRO n√£o configurado.")
    url = f"{SERPRO_BASE.rstrip('/')}/cadin/v1/consulta/{only_digits(document)}"
    r = requests.get(url, headers={"Authorization": f"Bearer {SERPRO_TOKEN}"}, timeout=45)
    r.raise_for_status()
    return r.json()

@st.cache_data(ttl=600, show_spinner=False)
def pmsp_pf(cpf: str, dtnasc_ddmmaaaa: str) -> Dict[str, Any]:
    if not (PMSP_GATEWAY_URL and PMSP_API_KEY):
        raise RuntimeError("Gateway PMSP n√£o configurado.")
    url = f"{PMSP_GATEWAY_URL.rstrip('/')}/cadin/pmspspf/{only_digits(cpf)}"
    r = requests.get(url, params={"dtnasc": dtnasc_ddmmaaaa}, headers={"X-API-Key": PMSP_API_KEY}, timeout=60)
    r.raise_for_status()
    return r.json()

@st.cache_data(ttl=600, show_spinner=False)
def pmsp_pj(cnpj: str) -> Dict[str, Any]:
    if not (PMSP_GATEWAY_URL and PMSP_API_KEY):
        raise RuntimeError("Gateway PMSP n√£o configurado.")
    url = f"{PMSP_GATEWAY_URL.rstrip('/')}/cadin/pmspspj/{only_digits(cnpj)}"
    r = requests.get(url, headers={"X-API-Key": PMSP_API_KEY}, timeout=60)
    r.raise_for_status()
    return r.json()

# =========================
# Normaliza√ß√£o
# =========================
def normalize(data: Dict[str, Any], doc: str) -> Dict[str, Any]:
    out: Dict[str, Any] = {}
    out["documento"] = only_digits(data.get("documento") or data.get("cpf") or data.get("cnpj") or doc)
    out["nome"] = data.get("nome") or data.get("razao_social") or data.get("razaoSocial") or "‚Äî"
    out["situacao"] = (data.get("situacao") or data.get("status") or "‚Äî").upper()
    pend = data.get("pendencias") or data.get("itens") or data.get("debts") or []
    if isinstance(pend, dict):
        pend = [pend]
    out["pendencias"] = pend
    out["_raw"] = data
    return out

def demo(doc: str) -> Dict[str, Any]:
    d = only_digits(doc)
    pf = is_cpf(d)
    irregular = (int(d[-1]) % 2 == 1) if d else False
    nome = "Pessoa F√≠sica (demo)" if pf else "Empresa Ltda (demo)" if is_cnpj(d) else "Documento (demo)"
    return normalize({
        "documento": d,
        "nome": nome,
        "situacao": "IRREGULAR" if irregular else "REGULAR",
        "pendencias": ([] if not irregular else [
            {"orgao": "PMSP" if pf else "Uni√£o", "origem": "Tributo", "numero": "000123/2024",
             "data": "2024-08-12", "valor": 199.90}
        ])
    }, d)

# =========================
# Orquestra√ß√£o
# =========================
def resolver_geral(documento: str) -> Tuple[Dict[str, Any], str]:
    # 1) gateway
    if GATEWAY_URL and INTERNAL_API_KEY:
        try:
            return normalize(via_gateway(documento), documento), "gateway"
        except Exception as e:
            st.warning(f"Gateway falhou: {e}")

    # 2) serpro
    if SERPRO_BASE and SERPRO_TOKEN:
        try:
            return normalize(via_serpro(documento), documento), "serpro"
        except Exception as e:
            st.warning(f"SERPRO falhou: {e}")

    # 3) demo
    return demo(documento), "demo"

def resolver_pmsp(documento: str, dtnasc_ddmmaaaa: Optional[str]) -> Tuple[Optional[Dict[str, Any]], Optional[str]]:
    if not (PMSP_GATEWAY_URL and PMSP_API_KEY):
        return None, None
    if is_cpf(documento):
        if not dtnasc_ddmmaaaa or not re.match(r"^\d{2}/\d{2}/\d{4}$", dtnasc_ddmmaaaa.strip()):
            st.error("Para **PMSP ‚Äì PF**, informe **data de nascimento** no formato dd/mm/aaaa.")
            return None, None
        try:
            return normalize(pmsp_pf(documento, dtnasc_ddmmaaaa.strip()), documento), "pmsp_pf"
        except Exception as e:
            st.warning(f"PMSP PF falhou: {e}")
            return None, None
    if is_cnpj(documento):
        try:
            return normalize(pmsp_pj(documento), documento), "pmsp_pj"
        except Exception as e:
            st.warning(f"PMSP PJ falhou: {e}")
            return None, None
    st.error("Documento inv√°lido para PMSP.")
    return None, None

# =========================
# Sidebar
# =========================
with st.sidebar:
    st.subheader("‚öôÔ∏è Configura√ß√µes")
    if GATEWAY_URL and INTERNAL_API_KEY:
        st.success("Gateway padr√£o configurado"); st.write(f"**Gateway:** {GATEWAY_URL}")
    else:
        st.info("Sem gateway padr√£o. Configure **GATEWAY_URL** e **INTERNAL_API_KEY**.")

    if SERPRO_BASE and SERPRO_TOKEN:
        st.success("SERPRO direto configurado")
    else:
        st.info("Sem SERPRO direto. (opcional)")

    if PMSP_GATEWAY_URL and PMSP_API_KEY:
        st.success("Gateway **PMSP** configurado (PF & PJ)")
        pmsp_on = st.checkbox("Usar CADIN Municipal PMSP (PF/PJ)", value=True)
    else:
        st.info("Sem gateway PMSP. Configure **PMSP_GATEWAY_URL** e **PMSP_API_KEY**.")
        pmsp_on = False

    st.markdown("---")
    modo = st.radio("Modos de consulta", ["Consulta √∫nica", "Lote (CSV)"], index=0)

# =========================
# UI
# =========================
def card_resultado(payload: Dict[str, Any], fonte: str):
    doc = payload.get("documento", "")
    st.subheader(f"Resultado ‚Äî {label_doc(doc)} {fmt_doc(doc)}")
    st.write("**Fonte:**", fonte.upper())
    st.write("**Nome/Raz√£o social:**", payload.get("nome", "‚Äî"))
    situ = (payload.get("situacao") or "‚Äî").upper()
    st.write("**Situa√ß√£o:**", "üü• IRREGULAR" if situ == "IRREGULAR" else "üü© REGULAR")

    st.markdown("---")
    st.subheader("üîé Pend√™ncias")
    pend = payload.get("pendencias") or []
    if not pend:
        st.success("Sem pend√™ncias retornadas.")
    else:
        df = pd.DataFrame(pend)
        if "valor" in df.columns:
            with pd.option_context("mode.use_inf_as_na", True):
                df["valor"] = pd.to_numeric(df["valor"], errors="coerce")
        st.dataframe(df, use_container_width=True)

    with st.expander("JSON bruto / depura√ß√£o"):
        st.json(payload.get("_raw", payload))

def tela_unica(pmsp: bool):
    with st.form("form_unico"):
        doc = st.text_input("CPF ou CNPJ", placeholder="000.000.000-00 ou 00.000.000/0001-00")
        dtnasc = st.text_input("Data de nascimento (PMSP ‚Äì PF)", placeholder="dd/mm/aaaa") if pmsp else ""
        ok = st.form_submit_button("Consultar")

    if not ok:
        return

    d = only_digits(doc)
    if len(d) not in (11, 14):
        st.error("Informe um CPF (11 d√≠gitos) ou CNPJ (14 d√≠gitos).")
        return

    with st.spinner("Consultando..."):
        payload, fonte = (None, None)
        if pmsp:
            payload, fonte = resolver_pmsp(d, dtnasc)
        if payload is None:
            payload, fonte = resolver_geral(d)

    card_resultado(payload, fonte)

def tela_lote(pmsp: bool):
    st.write("Envie um **CSV** com coluna `documento` (CPF/CNPJ). "
             "Se usar **PMSP** e houver **CPF**, inclua tamb√©m a coluna `dtnasc` (dd/mm/aaaa) para esses CPFs.")
    up = st.file_uploader("CSV", type=["csv"])
    if not up:
        return

    try:
        df = pd.read_csv(up, dtype=str)
    except Exception as e:
        st.error(f"Erro ao ler CSV: {e}")
        return

    if "documento" not in df.columns:
        st.error("CSV deve conter a coluna `documento`.")
        return

    docs = [only_digits(x) for x in df["documento"].fillna("").astype(str)]
    docs = [d for d in docs if len(d) in (11, 14)]
    if not docs:
        st.error("Nenhum CPF/CNPJ v√°lido no CSV.")
        return

    out: List[Dict[str, Any]] = []
    prog = st.progress(0.0)
    total = len(docs)

    for i, d in enumerate(docs, start=1):
        payload, fonte = (None, None)
        if pmsp:
            dtn = ""
            if is_cpf(d) and "dtnasc" in df.columns:
                try:
                    dtn = str(df.loc[df.index[i-1], "dtnasc"] or "").strip()
                except Exception:
                    dtn = ""
            p, f = resolver_pmsp(d, dtn)
            if p is not None:
                payload, fonte = p, f
        if payload is None:
            payload, fonte = resolver_geral(d)

        pend = payload.get("pendencias") or []
        out.append({
            "documento": fmt_doc(d),
            "tipo": label_doc(d),
            "nome": payload.get("nome", ""),
            "situacao": payload.get("situacao", ""),
            "qtd_pendencias": len(pend),
            "fonte": fonte
        })
        prog.progress(i / total)

    tabela = pd.DataFrame(out)
    st.subheader("üìä Resumo do lote")
    st.dataframe(tabela, use_container_width=True)
    st.download_button(
        "Baixar CSV",
        tabela.to_csv(index=False).encode("utf-8-sig"),
        file_name="resultado_cadin.csv",
        mime="text/csv"
    )

# =========================
# Main
# =========================
with st.sidebar:
    st.markdown("---")

if modo == "Consulta √∫nica":
    tela_unica(pmsp_on)
else:
    tela_lote(pmsp_on)

st.markdown("---")
st.caption("App demonstrativo. Para uso em produ√ß√£o, garanta base legal/consentimento (LGPD) e credenciais oficiais.")
